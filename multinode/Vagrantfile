
$fixsysconf = <<-SCRIPT
sed -i '/net.ipv6.conf.all.disable_ipv6/d' /etc/sysctl.conf
sed -i 's/^#net.ipv4.ip_forward/net.ipv4.ip_forward/' /etc/sysctl.conf
sed -i 's/^#net.ipv6.conf.all.forwarding/net.ipv6.conf.all.forwarding/' /etc/sysctl.conf
sed -i 's/^#net.ipv4.conf.all.log_martians/net.ipv4.conf.all.log_martians/' /etc/sysctl.conf
sysctl -p /etc/sysctl.conf
SCRIPT

$deleth0dhcpdefault = <<-SCRIPT
sed -i '/^[[:space:]]*dhcp4:[[:space:]]true/a \\     \\ dhcp4-overrides:' /etc/netplan/01-netcfg.yaml
sed -i '/^[[:space:]]*dhcp4-overrides:/a \\       \\ use-routes: false'  /etc/netplan/01-netcfg.yaml 
SCRIPT

$fixhosts = <<-SCRIPT
sed -i '/ubuntu2004/d' /etc/hosts
sed -i 's/^127.0.2.1/127.0.1.1/' /etc/hosts
SCRIPT

$routerasdefault = <<-SCRIPT
sed -i  '$ a \\     \\ gateway4: 192.168.254.1' /etc/netplan/50-vagrant.yaml
SCRIPT




# This var (which can be overridden with the EPIC_PRIVATE_REGISTRY env
# var) tells the snap package to configure containerd to use a private
# (i.e., insecure) registry. For example, if the value of
# EPIC_PRIVATE_REGISTRY is 192.168.1.80:5000 then containerd will be
# able to pull images from that registry using plain http. The default
# value is localhost:32000 which works with the registry that you get
# when you run "microk8s.enable registry".
EPIC_PRIVATE_REGISTRY = ENV.fetch('EPIC_PRIVATE_REGISTRY', 'localhost:32000')

$epicmgr = <<-SCRIPT
# create the epicmgr group so I can add the vagrant user to it
groupadd --force --system epicmgr
# add vagrant to some useful groups
usermod -G systemd-journal,root,epicmgr -a vagrant
cat <<-ENVVARS >> /etc/environment
# set an env var so epicmgr will allow k8s to pull images from an insecure registry
EPIC_PRIVATE_REGISTRY="#{EPIC_PRIVATE_REGISTRY}"
ENVVARS
SCRIPT

$installmk8s = <<-SCRIPT
snap install microk8s --classic --channel=1.22/stable
usermod -a -G microk8s vagrant
chown -f -R vagrant ~/.kube
microk8s status --wait-ready
microk8s enable dns rbac helm3
# hack containerd config to allow k8s to pull images from an insecure registry
sed --in-place=.bak --expression="s@localhost:32000@#{EPIC_PRIVATE_REGISTRY}@g" /var/snap/microk8s/current/args/containerd-template.toml ; microk8s.stop ; microk8s.start
SCRIPT


Vagrant.configure("2") do |config|

BRIDGE = "#{ENV['USER']}" + "-epic0"
EXTBRIDGE = "brext0"
LVMPOOL = "default"


  config.vm.define 'router' do |router|
    router.trigger.before :up do |uptrigger|
      uptrigger.info = "running before up"
      uptrigger.run = {inline: "/usr/local/bin/brmgr.sh up" }
    end
    router.trigger.after :destroy do |destroytrigger|
      destroytrigger.info = "running after destroy"
      destroytrigger.run = {inline: "/usr/local/bin/brmgr.sh destroy"}
    end
    router.vm.hostname = 'router'
    router.vm.box = "frrouter"
    router.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      auto_config: false
    router.vm.network :public_network,
      :dev => EXTBRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      auto_config: false
    
    router.vm.provider :libvirt do |lv|
      lv.cpus = 2
      lv.memory = 2048
      lv.storage_pool_name = LVMPOOL
    end
    router.vm.provision "shell", inline: $fixsysconf
    router.vm.provision "shell", inline: $fixhosts
    router.vm.provision "shell", inline: $deleth0dhcpdefault
    router.vm.provision "shell", inline: "netplan apply"
  end
 
  config.vm.define 'epic1' do |epic1|
    epic1.vm.hostname = 'epic1'
    epic1.vm.box = "generic/ubuntu2004"
    epic1.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      ip: "192.168.254.11"

    epic1.vm.provider :libvirt do |lv|
      lv.cpus = 4
      lv.memory = 6148
      lv.storage_pool_name = LVMPOOL
    end
    epic1.vm.provision "shell", inline: $fixsysconf
    epic1.vm.provision "shell", inline: $fixhosts
    epic1.vm.provision "shell", inline: $deleth0dhcpdefault
    epic1.vm.provision "shell", inline: $routerasdefault
    epic1.vm.provision "shell", inline: "netplan apply"
    epic1.vm.provision "shell", inline: $epicmgr

    epic1.vm.provision "file", source: "../files/epic_hosts", destination: "epic_hosts"
    epic1.vm.provision "shell", inline: "cat epic_hosts >> /etc/hosts"
    epic1.vm.provision "file", source: "../files/resolved.conf", destination: "resolved.conf"
    epic1.vm.provision "shell", inline: "mv resolved.conf /etc/systemd/resolved.conf"


  end

  config.vm.define 'epic2' do |epic2|
    epic2.vm.hostname = 'epic2'
    epic2.vm.box = "generic/ubuntu2004"
    epic2.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      ip: "192.168.254.12"

    epic2.vm.provider :libvirt do |lv|
      lv.cpus = 4
      lv.memory = 6148
      lv.storage_pool_name = LVMPOOL
    end
    epic2.vm.provision "shell", inline: $fixsysconf
    epic2.vm.provision "shell", inline: $fixhosts
    epic2.vm.provision "shell", inline: $deleth0dhcpdefault
    epic2.vm.provision "shell", inline: $routerasdefault
    epic2.vm.provision "shell", inline: "netplan apply"
    epic2.vm.provision "shell", inline: $epicmgr

    epic2.vm.provision "file", source: "../files/epic_hosts", destination: "epic_hosts"
    epic2.vm.provision "shell", inline: "cat epic_hosts >> /etc/hosts"
    epic2.vm.provision "file", source: "../files/resolved.conf", destination: "resolved.conf"
    epic2.vm.provision "shell", inline: "mv resolved.conf /etc/systemd/resolved.conf"

  end

  config.vm.define 'epic3' do |epic3|
    epic3.vm.hostname = 'epic3'
    epic3.vm.box = "generic/ubuntu2004"
    epic3.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      ip: "192.168.254.13"

    epic3.vm.provider :libvirt do |lv|
      lv.cpus = 4
      lv.memory = 6148
      lv.storage_pool_name = LVMPOOL
    end
    epic3.vm.provision "shell", inline: $fixsysconf
    epic3.vm.provision "shell", inline: $fixhosts
    epic3.vm.provision "shell", inline: $deleth0dhcpdefault
    epic3.vm.provision "shell", inline: $routerasdefault
    epic3.vm.provision "shell", inline: "netplan apply"
    epic3.vm.provision "shell", inline: $epicmgr

    epic3.vm.provision "file", source: "../files/epic_hosts", destination: "epic_hosts"
    epic3.vm.provision "shell", inline: "cat epic_hosts >> /etc/hosts"
    epic3.vm.provision "file", source: "../files/resolved.conf", destination: "resolved.conf"
    epic3.vm.provision "shell", inline: "mv resolved.conf /etc/systemd/resolved.conf"

  end

  config.vm.define 'mk8s1' do |mk8s1|
    mk8s1.vm.hostname = 'mk8s1'
    mk8s1.vm.box = "generic/ubuntu2004"
    mk8s1.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      ip: "192.168.254.101"

    mk8s1.vm.provider :libvirt do |lv|
      lv.cpus = 2
      lv.memory = 4096
      lv.storage_pool_name = LVMPOOL
    end
    mk8s1.vm.provision "shell", inline: $fixsysconf
    mk8s1.vm.provision "shell", inline: $fixhosts
    mk8s1.vm.provision "shell", inline: $deleth0dhcpdefault
    mk8s1.vm.provision "shell", inline: $routerasdefault
    mk8s1.vm.provision "shell", inline: "netplan apply"

    mk8s1.vm.provision "file", source: "../files/mk8s_hosts", destination: "mk8s_hosts"
    mk8s1.vm.provision "shell", inline: "cat mk8s_hosts >> /etc/hosts"
   

    mk8s1.vm.provision "shell", inline: $installmk8s

    mk8s1.vm.provision "file", source: "../files/kubens", destination: "kubens"
    mk8s1.vm.provision "shell", inline: "mv kubens /usr/local/bin"

    mk8s1.vm.provision "file", source: "../files/bash_aliases", destination: ".bash_aliases" 

    mk8s1.vm.provision "file", source: "../files/resolved.conf", destination: "resolved.conf"
    mk8s1.vm.provision "shell", inline: "mv resolved.conf /etc/systemd/resolved.conf"
    
  end

  config.vm.define 'mk8s2' do |mk8s2|
    mk8s2.vm.hostname = 'mk8s2'
    mk8s2.vm.box = "generic/ubuntu2004"
    mk8s2.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      ip: "192.168.254.102"

    mk8s2.vm.provider :libvirt do |lv|
      lv.cpus = 2
      lv.memory = 4096
      lv.storage_pool_name = LVMPOOL
    end
    mk8s2.vm.provision "shell", inline: $fixsysconf
    mk8s2.vm.provision "shell", inline: $fixhosts
    mk8s2.vm.provision "shell", inline: $deleth0dhcpdefault
    mk8s2.vm.provision "shell", inline: $routerasdefault
    mk8s2.vm.provision "shell", inline: "netplan apply"

    mk8s2.vm.provision "file", source: "../files/mk8s_hosts", destination: "mk8s_hosts"
    mk8s2.vm.provision "shell", inline: "cat mk8s_hosts >> /etc/hosts"
    
    mk8s2.vm.provision "shell", inline: $installmk8s

    mk8s2.vm.provision "file", source: "../files/kubens", destination: "kubens"
    mk8s2.vm.provision "shell", inline: "mv kubens /usr/local/bin"

    mk8s2.vm.provision "file", source: "../files/bash_aliases", destination: ".bash_aliases" 

    mk8s2.vm.provision "file", source: "../files/resolved.conf", destination: "resolved.conf"
    mk8s2.vm.provision "shell", inline: "mv resolved.conf /etc/systemd/resolved.conf"
  
  end
  
  config.vm.define 'mk8s3' do |mk8s3|
    mk8s3.vm.hostname = 'mk8s3'
    mk8s3.vm.box = "generic/ubuntu2004"
    mk8s3.vm.network :public_network, 
      :dev => BRIDGE,
      :mode => "bridge",
      :type => "bridge",
      :trust_guest_rx_filters => "true",
      ip: "192.168.254.103"

    mk8s3.vm.provider :libvirt do |lv|
      lv.cpus = 2
      lv.memory = 4096
      lv.storage_pool_name = LVMPOOL
    end
    mk8s3.vm.provision "shell", inline: $fixsysconf
    mk8s3.vm.provision "shell", inline: $fixhosts
    mk8s3.vm.provision "shell", inline: $deleth0dhcpdefault
    mk8s3.vm.provision "shell", inline: $routerasdefault
    mk8s3.vm.provision "shell", inline: "netplan apply"

    mk8s3.vm.provision "file", source: "../files/mk8s_hosts", destination: "mk8s_hosts"
    mk8s3.vm.provision "shell", inline: "cat mk8s_hosts >> /etc/hosts"


    mk8s3.vm.provision "shell", inline: $installmk8s

    mk8s3.vm.provision "file", source: "../files/kubens", destination: "kubens"
    mk8s3.vm.provision "shell", inline: "mv kubens /usr/local/bin"

    mk8s3.vm.provision "file", source: "../files/bash_aliases", destination: ".bash_aliases" 

    mk8s3.vm.provision "file", source: "../files/resolved.conf", destination: "resolved.conf"
    mk8s3.vm.provision "shell", inline: "mv resolved.conf /etc/systemd/resolved.conf"
    
    
  end

 
end
